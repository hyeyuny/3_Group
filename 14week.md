# 14week

### <질의응답>

<aside>
💡 예제 13-1이 이해가 잘 안 되는데 설명해줄 수 있어?

</aside>

응 알았어 먼저 `Select_Sort` 함수는 배열의 주소와 배열의 크기를 인자로 받아.

바깥쪽 `for` 루프에서는 배열의 각 원소에 대해 반복해. 이 때, 마지막 원소는 이미 나머지 원소들이 정렬되면 자동으로 정렬되므로, 반복은 배열의 마지막 원소 전까지만 진행해.

매 반복마다, 현재 원소를 가장 작은 값으로 가정하고, 이 원소의 인덱스를 `min_index`에, 원소의 값을 `min_value`에 저장해.

그리고 안쪽 `for` 루프에서는 현재 원소의 다음 원소부터 배열의 끝까지 반복하며, 현재 가장 작은 값(`min_value`)보다 더 작은 값을 찾아.

만약 더 작은 값을 찾으면, 그 값과 그 값의 인덱스를 `min_value`와 `min_index`에 갱신해.

안쪽 루프가 끝나면, 가장 작은 값이 어디에 있는지(`min_index`), 그리고 그 값이 무엇인지(`min_value`) 알게 될거야.

그런 다음, 가장 작은 값과 바깥쪽 루프의 현재 원소를 교환하여, 가장 작은 값이 배열의 앞부분으로 이동하게 돼.

<aside>
💡 그럼 선택 정렬이 다른 정렬에 비해 효율적이지 않을 때가 있어?

</aside>

응, 선택 정렬은 배열 내에서 가장 작은 값을 찾아 앞으로 옮기는 방식으로 작동해. 

이 방식은 각 단계에서 전체 배열을 확인하게 되므로, 배열의 크기가 큰 경우 많은 단계를 거쳐야 해. 즉, 데이터의 양이 많아질수록 선택 정렬로 데이터를 정렬하는 데 필요한 단계 수가 많아져서 더 많은 시간이 소요되지.

특히, 이미 정렬된 데이터나 거의 정렬된 데이터에 대해서도 선택 정렬은 모든 데이터를 확인해야 하므로 비효율적일 수 있어. 

그래서 데이터의 크기가 큰 경우나 데이터가 이미 거의 정렬된 상태인 경우에는 다른 정렬 방법을 사용하는 것이 더 효율적일거야.

<aside>
💡 덕분에 버블 정렬도 잘 이해할 수 있었어 근데 이 데이터를 반대로 내림차순으로 정렬할 수 있어?

</aside>

응. 이건 **`if(a[j-1] > a[j])`** 를 **`if(a[j-1] < a[j])`** 로 바꾸면 돼

```jsx
#include <stdio.h>
void Bubble_Sort(int* a, int count);
int main(void)
{
int data[] = { 4, 2, 20, 8, 1, 33, 35, 9, 6, 26 };
int i;
printf("정렬전 데이터\\n");

for (i = 0; i < 10; i++)
    printf("[%d] ", data[i]);

Bubble_Sort(data, 10);
puts("\\n");

printf("정렬후 데이터\\n");

for (i = 0; i < 10; i++)
    printf("[%d] ", data[i]);

puts("\\n");
return 0;
}
void Bubble_Sort(int* a, int count)
{
int i, j;
int temp;
for (i = 0; i < count - 1; i++)
{
    for (j = 1; j < count - i; j++)
    {
        if (a[j - 1] < a[j])
        {
            temp = a[j - 1];
            a[j - 1] = a[j];
            a[j] = temp;
        }
    }
 }
}
```